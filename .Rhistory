m0 = seq_along(metabolisms) - 1
)
grid <- transform(grid0, x = x0 * s, y = y0 * s, z = z0 * s)
grid$cancer     <- tcga_types[grid0$x0 + 1]
grid$omic       <- omics[grid0$y0 + 1]
grid$phenotype  <- phenotypes[grid0$z0 + 1]
grid$metabolism <- metabolisms[grid0$m0 + 1]
grid$metabolism <- factor(grid$metabolism, levels = metabolisms)
set.seed(123)
grid$score <- runif(nrow(grid), min = 0, max = 1)
phenotype_colors <- setNames(c("red","orange","purple","brown","darkred"), phenotypes)
grid$phenotype_color <- phenotype_colors[grid$phenotype]
# IDs estáveis por ponto (constantes entre frames)
grid$id <- interaction(grid$cancer, grid$omic, grid$phenotype, drop = TRUE)
# 4) Lattice ------------------------------------------------------------
make_segment_df <- function(x0, y0, z0, x1, y1, z1) {
data.frame(x = c(x0, x1, NA), y = c(y0, y1, NA), z = c(z0, z1, NA))
}
lat_vert <- do.call(rbind, lapply(0:(length(tcga_types)-1), function(xx) {
xv <- xx * s
do.call(rbind, lapply(0:(length(omics)-1), function(yy) {
yv <- yy * s
make_segment_df(xv, yv, 0, xv, yv, (length(phenotypes)-1) * s)
}))
}))
lat_y <- do.call(rbind, lapply(0:(length(tcga_types)-1), function(xx) {
xv <- xx * s
do.call(rbind, lapply(0:(length(phenotypes)-1), function(zz) {
zv <- zz * s
make_segment_df(xv, 0, zv, xv, (length(omics)-1) * s, zv)
}))
}))
lat_x <- do.call(rbind, lapply(0:(length(omics)-1), function(yy) {
yv <- yy * s
do.call(rbind, lapply(0:(length(phenotypes)-1), function(zz) {
zv <- zz * s
make_segment_df(0, yv, zv, (length(tcga_types)-1) * s, yv, zv)
}))
}))
lattice <- rbind(lat_vert, lat_y, lat_x)
# 5) Plotly cube (defina width/height aqui) -----------------------------
p <- plot_ly(width = 1500, height = 1100)
# Arestas (fixas, sem frame)
p <- add_trace(
p, type="scatter3d", mode="lines",
x=lattice$x, y=lattice$y, z=lattice$z,
line=list(color="gray", width=1),
hoverinfo="skip", showlegend=FALSE
)
# 5b) Traços por frame (manual) -----------------------------------------
for (m in metabolisms) {
dfm <- subset(grid, metabolism == m)
dfm$size <- 5 + 10 * dfm$score
cd_m <- I(cbind(
dfm$cancer, dfm$omic, dfm$phenotype,
as.character(dfm$metabolism), round(dfm$score, 3)
))
# a) Fenótipo (categórico)
p <- add_trace(
p, data = dfm, type = "scatter3d", mode = "markers",
x = ~x, y = ~y, z = ~z,
frame = as.character(m),    # frame nomeado manualmente
ids   = ~id,
marker = list(
size  = dfm$size,
color = dfm$phenotype_color,
line  = list(width = 0.5, color = "black")
),
customdata   = cd_m,
hovertemplate = paste(
"Cancer: %{customdata[0]}<br>",
"Omic: %{customdata[1]}<br>",
"Phenotype: %{customdata[2]}<br>",
"Metabolism: %{customdata[3]}<br>",
"Score: %{customdata[4]}<extra></extra>"
),
showlegend = (m == metabolisms[1]),
name = "By phenotype",
visible = TRUE               # modo inicial
)
# b) Score (contínuo)
p <- add_trace(
p, data = dfm, type = "scatter3d", mode = "markers",
x = ~x, y = ~y, z = ~z,
frame = as.character(m),
ids   = ~id,
marker = list(
size      = dfm$size,
color     = dfm$score,
colorscale = "Viridis",
showscale  = TRUE,
colorbar   = list(title = "Score"),
line  = list(width = 0.5, color = "black")
),
customdata   = cd_m,
hovertemplate = paste(
"Cancer: %{customdata[0]}<br>",
"Omic: %{customdata[1]}<br>",
"Phenotype: %{customdata[2]}<br>",
"Metabolism: %{customdata[3]}<br>",
"Score: %{customdata[4]}<extra></extra>"
),
showlegend = (m == metabolisms[1]),
name = "By score",
visible = FALSE              # alternado pelo botão
)
}
# 6) Layout -------------------------------------------------------------
x_tickvals <- (0:(length(tcga_types)-1)) * s
x_ticktext <- ifelse((seq_along(tcga_types) %% 2) == 1, tcga_types, "")
# Visibilidades globais para os botões (1 aresta + 2*#metab traces)
visible_pheno <- c(TRUE, rep(c(TRUE,  FALSE), length(metabolisms)))
visible_score <- c(TRUE, rep(c(FALSE, TRUE ), length(metabolisms)))
p <- layout(
p,
title="Multi-Omic Cube + Metabolism (frames) — alternate TCGA labels; axis titles far away",
scene=list(
domain = list(x = c(0, 0.82), y = c(0, 1)),
xaxis=list(
title=list(text="TCGA Cancer Types (33)", standoff=160),
tickmode="array",
tickvals=x_tickvals,
ticktext=x_ticktext,
tickfont=list(size=11),
ticklen=10,
ticks="outside",
color="blue",
automargin=TRUE
),
yaxis=list(
title=list(text="Omic Layers (7)", standoff=160),
tickmode="array",
tickvals=(0:(length(omics)-1))*s,
ticktext=omics,
tickfont=list(size=12),
ticklen=10,
ticks="outside",
color="green",
automargin=TRUE
),
zaxis=list(
title=list(text="Phenotypes (5)", standoff=160),
tickmode="array",
tickvals=(0:(length(phenotypes)-1))*s,
ticktext=phenotypes,
tickfont=list(size=12),
ticklen=10,
ticks="outside",
color="red",
automargin=TRUE
),
aspectmode="cube"
),
margin=list(l=280, r=380, b=360, t=150),
legend=list(
x=1.36, y=0.5,
orientation="v",
bgcolor="rgba(255,255,255,0.85)",
bordercolor="black", borderwidth=0.6
),
updatemenus=list(list(
type="buttons", direction="right",
x=0.5, y=1.10, xanchor="center", yanchor="top",
buttons=list(
list(label="Color by Phenotype", method="update",
args=list(list(visible = visible_pheno),
list(title="Multi-Omic Cube + Metabolism — Color by Phenotype"))),
list(label="Color by Score (Viridis)", method="update",
args=list(list(visible = visible_score),
list(title="Multi-Omic Cube + Metabolism — Color by Score (Viridis)")))
)
))
)
# 7) Animação (sem animation_slider) -----------------------------------
p <- animation_opts(p, frame = 600, transition = 300, redraw = FALSE)
# 8) Exportação ---------------------------------------------------------
outfile <- "fair_cube_tcga_omics_phenotypes_metabolism_frames.html"
saveWidget(as_widget(p), file=outfile, selfcontained=TRUE)
suppressPackageStartupMessages({
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(forcats)
library(readr)
})
## ------------------------------------------------------------
## 1) INPUTS — Replace the toy examples with your real data
## ------------------------------------------------------------
## REQUIRED: Mapping of signatures to their single shared regulator
## If a signature has >1 shared regulator, expand to one row per pair.
## Columns:
##   signature_id : chr
##   regulator_id : chr   (miRNA or lncRNA identifier)
##   cancer_type  : chr   (TCGA code)
##   omic_layer   : chr   ("mRNA","miRNA","lncRNA","isoform", etc.)
map_sr <- tibble::tribble(
~signature_id, ~regulator_id, ~cancer_type, ~omic_layer,
"SIG001",      "miR-21",      "LUAD",       "mRNA",
"SIG002",      "miR-155",     "BRCA",       "mRNA",
"SIG003",      "HOTAIR",      "COAD",       "mRNA",
"SIG004",      "MALAT1",      "HNSC",       "mRNA"
)
## REQUIRED: Association table (long format) for both signatures and regulators
## Columns:
##   entity_type : chr in {"signature","regulator"}
##   entity_id   : chr (signature_id or regulator_id)
##   domain      : chr in {"phenotype","clinical","immune"}
##   measure     : chr (e.g., MSI/TMB/stemness; OS/DSS/DFI/PFI; immune_class or immune axis)
##   direction   : int in {-1, 1}  (association direction; never encode 0 here)
##   significant : lgl (TRUE/FALSE) — only TRUE is considered in comparisons
## NOTE: The 'measure' values define what is aggregated within each domain.
assoc <- tibble::tribble(
~entity_type, ~entity_id, ~domain,      ~measure,    ~direction, ~significant,
"signature",  "SIG001",   "phenotype",  "MSI",              -1L,  TRUE,
"signature",  "SIG001",   "phenotype",  "TMB",               1L,  TRUE,
"signature",  "SIG001",   "phenotype",  "stemness",          1L,  TRUE,
"signature",  "SIG001",   "clinical",   "OS",                1L,  TRUE,
"signature",  "SIG001",   "immune",     "hot_cold",          1L,  TRUE,
"regulator",  "miR-21",   "phenotype",  "MSI",              -1L,  TRUE,
"regulator",  "miR-21",   "phenotype",  "TMB",               1L,  TRUE,
"regulator",  "miR-21",   "phenotype",  "stemness",          1L,  TRUE,
"regulator",  "miR-21",   "clinical",   "OS",               -1L,  TRUE,
"regulator",  "miR-21",   "immune",     "hot_cold",          1L,  TRUE,
"signature",  "SIG002",   "phenotype",  "MSI",               1L,  TRUE,
"signature",  "SIG002",   "clinical",   "OS",               -1L,  TRUE,
"signature",  "SIG002",   "immune",     "hot_cold",         -1L,  TRUE,
"regulator",  "miR-155",  "phenotype",  "MSI",               1L,  TRUE,
"regulator",  "miR-155",  "clinical",   "OS",                1L,  TRUE,
"regulator",  "miR-155",  "immune",     "hot_cold",          1L,  TRUE,
"signature",  "SIG003",   "phenotype",  "TMB",               1L,  TRUE,
"signature",  "SIG003",   "clinical",   "DSS",               1L,  TRUE,
"signature",  "SIG003",   "immune",     "hot_cold",          1L,  TRUE,
"regulator",  "HOTAIR",   "phenotype",  "TMB",               1L,  TRUE,
"regulator",  "HOTAIR",   "clinical",   "DSS",               1L,  TRUE,
"regulator",  "HOTAIR",   "immune",     "hot_cold",          1L,  TRUE,
"signature",  "SIG004",   "phenotype",  "stemness",         -1L,  TRUE,
"signature",  "SIG004",   "clinical",   "PFI",              -1L,  TRUE,
"signature",  "SIG004",   "immune",     "hot_cold",          1L,  TRUE,
"regulator",  "MALAT1",   "phenotype",  "stemness",          1L,  TRUE,
"regulator",  "MALAT1",   "clinical",   "PFI",               1L,  TRUE,
"regulator",  "MALAT1",   "immune",     "hot_cold",         -1L,  TRUE
)
View(assoc)
View(map_sr)
## ------------------------------------------------------------
## 2) Helper: domain-wise comparison per pair
## ------------------------------------------------------------
## Compares signature vs regulator within a domain by aligning on 'measure'.
## Returns one of {"convergent","divergent","mixed","undefined"}:
##   - "convergent" : all overlapping significant measures have the same sign
##   - "divergent"  : all overlapping significant measures have opposite signs
##   - "mixed"      : overlapping significant measures contain both same and opposite
##   - "undefined"  : no overlapping significant measures
compare_domain <- function(df_sig, df_reg) {
if (nrow(df_sig) == 0L || nrow(df_reg) == 0L) return("undefined")
df <- inner_join(df_sig, df_reg, by = "measure", suffix = c("_sig","_reg")) %>%
filter(significant_sig, significant_reg)
if (nrow(df) == 0L) return("undefined")
same <- sum(df$direction_sig == df$direction_reg, na.rm = TRUE)
oppo <- sum(df$direction_sig == -df$direction_reg, na.rm = TRUE)
total <- nrow(df)
if (same == total) return("convergent")
if (oppo == total) return("divergent")
"mixed"
}
## ------------------------------------------------------------
## 3) Compute domain status matrix per signature–regulator pair
## ------------------------------------------------------------
domains <- c("phenotype","clinical","immune")
status_mat <- map_sr %>%
rowwise() %>%
do({
sig_id <- .$signature_id
reg_id <- .$regulator_id
out <- tibble(signature_id = sig_id,
regulator_id = reg_id,
cancer_type  = .$cancer_type,
omic_layer   = .$omic_layer)
# collect per-domain status
for (dm in domains) {
sig_sub <- assoc %>% filter(entity_type=="signature",
entity_id==sig_id, domain==dm)
reg_sub <- assoc %>% filter(entity_type=="regulator",
entity_id==reg_id, domain==dm)
out[[paste0("status_", dm)]] <- compare_domain(sig_sub, reg_sub)
}
out
}) %>%
bind_rows() %>%
ungroup()
## ------------------------------------------------------------
## 4) Derive dominant pattern (for Panel B)
## ------------------------------------------------------------
## Rule:
##   convergent_count = number of domains == "convergent"
##   divergent_count  = number of domains == "divergent"
##   If convergent_count > divergent_count -> "Convergent"
##   If divergent_count  > convergent_count -> "Divergent"
##   Else -> "Mixed/Undefined"
status_long <- status_mat %>%
pivot_longer(cols = starts_with("status_"),
names_to = "domain",
values_to = "status") %>%
mutate(domain = str_remove(domain, "^status_"))
dominant <- status_long %>%
group_by(signature_id, regulator_id, cancer_type, omic_layer) %>%
summarise(
convergent_count = sum(status == "convergent"),
divergent_count  = sum(status == "divergent"),
mixed_count      = sum(status == "mixed"),
undefined_count  = sum(status == "undefined"),
.groups = "drop"
) %>%
mutate(dominant_pattern = case_when(
convergent_count > divergent_count ~ "Convergent",
divergent_count  > convergent_count ~ "Divergent",
TRUE ~ "Mixed/Undefined"
))
## ------------------------------------------------------------
## 5) PANEL B — Dominant pattern bar (single bar with breakdown)
## ------------------------------------------------------------
panelB_df <- dominant %>%
count(dominant_pattern) %>%
mutate(pct = 100 * n / sum(n),
dominant_pattern = factor(dominant_pattern,
levels = c("Convergent","Divergent","Mixed/Undefined")))
pB <- ggplot(panelB_df, aes(x = "All pairs", y = pct, fill = dominant_pattern)) +
geom_bar(stat = "identity", width = 0.6, color = "black", linewidth = 0.2) +
geom_text(aes(label = sprintf("%.1f%%", pct)),
position = position_stack(vjust = 0.5), size = 3.5) +
labs(x = NULL, y = "Percentage of pairs",
title = "Dominant pattern across domains") +
scale_y_continuous(expand = expansion(mult = c(0.01, 0.05))) +
theme_bw(base_size = 11) +
theme(legend.title = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
plot.title = element_text(hjust = 0.5))
pB
## ------------------------------------------------------------
## 6) PANEL C — Domain matrix heatmap (+ / – / 0)
## ------------------------------------------------------------
## Map statuses to symbols:
##   convergent -> "+"
##   divergent  -> "–"
##   mixed/undefined -> "0"
sym_map <- c(convergent = "+", divergent = "–", mixed = "0", undefined = "0")
panelC_df <- status_long %>%
mutate(symbol = sym_map[status],
pair_id = paste(signature_id, regulator_id, sep = " | ")) %>%
mutate(domain = factor(domain, levels = c("phenotype","clinical","immune")))
pC <- ggplot(panelC_df, aes(x = domain, y = fct_rev(pair_id), label = symbol)) +
geom_tile(fill = "grey95", color = "white") +
geom_text(size = 4) +
labs(x = NULL, y = "Signature | Regulator",
title = "Per-domain convergence/divergence") +
theme_bw(base_size = 11) +
theme(panel.grid = element_blank(),
plot.title = element_text(hjust = 0.5),
axis.text.y = element_text(size = 8))
pC
wide_stat <- status_long %>%
select(signature_id, regulator_id, domain, status) %>%
pivot_wider(names_from = domain, values_from = status)
panelD_df <- wide_stat %>%
mutate(category = case_when(
phenotype == "convergent" & clinical == "divergent" ~ "Phenotype-convergent / Clinical-divergent",
clinical  == "convergent" & immune   == "divergent" ~ "Clinical-convergent / Immune-divergent",
phenotype == "convergent" & clinical == "convergent" & immune == "convergent" ~ "Fully convergent",
phenotype == "divergent"  & clinical == "divergent"  & immune == "divergent"  ~ "Fully divergent",
TRUE ~ "Other combinations"
)) %>%
count(category) %>%
mutate(pct = 100 * n / sum(n),
category = factor(category,
levels = c("Phenotype-convergent / Clinical-divergent",
"Clinical-convergent / Immune-divergent",
"Fully convergent",
"Fully divergent",
"Other combinations")))
pD <- ggplot(panelD_df, aes(x = "All pairs", y = pct, fill = category)) +
geom_bar(stat = "identity", width = 0.6, color = "black", linewidth = 0.2) +
geom_text(aes(label = sprintf("%.1f%%", pct)),
position = position_stack(vjust = 0.5), size = 3.2) +
labs(x = NULL, y = "Percentage of pairs",
title = "Domain-specific categories") +
scale_y_continuous(expand = expansion(mult = c(0.01, 0.05))) +
theme_bw(base_size = 11) +
theme(legend.title = element_blank(),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
plot.title = element_text(hjust = 0.5))
pD
View(panelD_df)
suppressPackageStartupMessages({
# Core Shiny
library(shiny)
library(shinycssloaders)
# Data handling and utilities
library(dplyr)
library(tidyr)
library(stringr)
library(tibble)
library(purrr)
library(readr)
library(readxl)
library(glue)
library(memoise)
library(qs)
# Plotting and visualization
library(ggplot2)
library(ggsci)
library(cowplot)
library(grid)
library(gridtext)
# Network & Graph visualization
library(igraph)
library(tidygraph)
library(ggraph)
# Biological / Survival Analysis
library(survival)
library(survminer)
library(fmsb)
library(ggradar)
# Shiny Data Tables
library(DT)
# UCSC Xena data utilities
library(UCSCXenaShiny)
library(UCSCXenaTools)
# Deployment (optional)
library(rsconnect)
# Development tools (optional but used in some parts of your code)
library(devtools)
})
packages <- c(
"shiny", "shinycssloaders",
"dplyr", "tidyr", "stringr", "tibble", "purrr", "readr", "readxl",
"glue", "memoise", "qs",
"ggplot2", "ggsci", "cowplot", "grid", "gridtext",
"igraph", "tidygraph", "ggraph",
"survival", "survminer", "fmsb", "ggradar",
"DT",
"UCSCXenaShiny", "UCSCXenaTools",
"rsconnect",
"devtools"
)
installed_versions <- sapply(packages, function(pkg) {
if (requireNamespace(pkg, quietly = TRUE)) {
as.character(packageVersion(pkg))
} else {
"NOT INSTALLED"
}
})
version_table <- data.frame(
Package = packages,
Version = installed_versions,
row.names = NULL
)
print(version_table)
# Configuração da conta rsconnect (caso necessário para deploy)
rsconnect::setAccountInfo(
name = 'oncometabolismgps',
token = '80069F69BF3E4A2F89B299A9F041C4AC',
secret = 'L0ibul0Jgx9ZcLxhF3HarvKUOJ58U/nSuzaeTqaJ'
)
# Caminho do app
rsconnect::deployApp(appDir = getwd(), appName = "Multi-omicOncometabolismGPSShiny")
setwd("E:/Geometric Multidimensional Representation/SigPolytope Shiny")
# Run the app
shiny::runApp()
# Configuração da conta rsconnect (caso necessário para deploy)
rsconnect::setAccountInfo(name='sigpolytope',
token='69DF9E7C3367060FDF341B81FEE95B4B',
secret='VcWCMmTvSkxDfqKN+nzKkMG/7EaJCcmKEDwSIztd')
# Caminho do app
rsconnect::deployApp(appDir = getwd(), appName = "geometricatlas")
# Run the app
shiny::runApp()
# Configuração da conta rsconnect (caso necessário para deploy)
rsconnect::setAccountInfo(name='sigpolytope',
token='69DF9E7C3367060FDF341B81FEE95B4B',
secret='VcWCMmTvSkxDfqKN+nzKkMG/7EaJCcmKEDwSIztd')
# Caminho do app
rsconnect::deployApp(appDir = getwd(), appName = "geometricatlas")
# Run the app
shiny::runApp()
# Run the app
shiny::runApp()
# Configuração da conta rsconnect (caso necessário para deploy)
rsconnect::setAccountInfo(name='sigpolytope',
token='69DF9E7C3367060FDF341B81FEE95B4B',
secret='VcWCMmTvSkxDfqKN+nzKkMG/7EaJCcmKEDwSIztd')
# Caminho do app
rsconnect::deployApp(appDir = getwd(), appName = "geometricatlas")
# Run the app
shiny::runApp()
# Run the app
shiny::runApp()
View(ALL_DATA)
# remover DS1, DS2, DS3
all_data[c("Dataset_S1", "Dataset_S2", "Dataset_S3")] <- NULL
# remover DS1, DS2, DS3
ALL_DATA[c("Dataset_S1", "Dataset_S2", "Dataset_S3")] <- NULL
# salvar novamente
saveRDS(ALL_DATA, "data/All_data.rds")
# Configuração da conta rsconnect (caso necessário para deploy)
rsconnect::setAccountInfo(name='sigpolytope',
token='69DF9E7C3367060FDF341B81FEE95B4B',
secret='VcWCMmTvSkxDfqKN+nzKkMG/7EaJCcmKEDwSIztd')
# Caminho do app
rsconnect::deployApp(appDir = getwd(), appName = "geometricatlas")
